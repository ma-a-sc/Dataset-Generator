import numpy as np
import pandas as pd
import array_functions as af
import random
import json


# This function creates a dataframe using the indexes returned by the 
# index_setter function, the list generated by the respective fill_x_array
# function and the specified variable name.
# This function basically generates a dataframe with one variable in it.
# This function will be called multiple times and then the one variable
# dataframes will be merged based on their indexes which will all be the same
# length.

def create_variable_number(var_type, num_of_obs, bot, top):
    # only differnece between the "int" and "float" option is which type of 
    # numbers are inserted into the dataframe. The way it works is the same.
    if var_type == "int":
        name = input("\nVariable name\n>")

        v_name =[name]

        how_many_obs = num_of_obs

        indexes = af.index_setter(how_many_obs) 

        list_for_array = af.fill_int_aray(bot, top, num_of_obs)
        
        int_dataframe = pd.DataFrame(list_for_array, index=indexes, 
        columns=v_name)

        return int_dataframe

    elif var_type == "float":
        name = input("\nVariable name\n>")

        v_name =[name]

        how_many_obs = num_of_obs

        indexes = af.index_setter(how_many_obs) 

        list_for_array = af.fill_float_array(bot, top, num_of_obs)

        float_dataframe = pd.DataFrame(list_for_array, index=indexes, 
        columns=v_name)

        return float_dataframe

    else:
        exit()

# This function creates a dataframe using the indexes returned by the 
# index_setter function, the list generated by the respective fill_x_array
# function and the specified variable name.
# This function basically generates a dataframe with one variable in it.
# This function will be called multiple times and then the one variable
# dataframes will be merged based on their indexes which will all be the same
# length.  

### I have to check what happens if the descriptive stats are called on a
### a string type array.

def create_variable_string_boolean_dummy(var_type, num_of_obs):

    if var_type == "string":
        name = input("\nVariable name\n>")

        v_name =[name]

        how_many_obs = num_of_obs

        indexes = af.index_setter(how_many_obs)

        list_of_choices = af.choices_loop()

        list_for_array = af.fill_string_array(list_of_choices, num_of_obs)

        string_dataframe = pd.DataFrame(list_for_array, index=indexes, 
        columns=v_name)

        return string_dataframe


    elif var_type == "boolean":
        name = input("\nVariable name\n>")

        v_name =[name]

        how_many_obs = num_of_obs

        indexes = af.index_setter(how_many_obs)

        list_of_choices = [True, False]

        array = af.fill_string_array(list_of_choices, num_of_obs)

        bool_dataframe= pd.DataFrame(array, index=indexes, 
        columns=v_name)

        return bool_dataframe
        
    elif var_type == "dummy":

        name = input("\nVariable name\n>")

        # For the dummy  type variable the "bot" and "top" arguemtns are renamed
        # no and yes cause that the only two options needed for a dummy 
        # variable.
        no = 0
        yes = 1

        v_name =[name]

        how_many_obs = num_of_obs

        indexes = af.index_setter(how_many_obs) 

        list_for_array = af.fill_int_aray(no, yes, num_of_obs)

        dummy_dataframe = pd.DataFrame(list_for_array, index=indexes, 
        columns=v_name)
        
        return dummy_dataframe


    else:
        exit()

# Calls the create_variable_number function "how_many_vars" number of times 
# with the type, the min(bot)/max(top) for the individal observation and the
# number of observation that should be generated.

def array_creation_num(how_many_vars, which_type, number_of_obs):
    x = 1

    bot = int(input("\nMinimum\n>"))

    top = int(input("\nMaximum\n>"))

    array = []

    while x <= how_many_vars:
        new_var = create_variable_number(which_type, number_of_obs, bot, top)
        array.append(new_var)
        x += 1

    return array

# Calls reate_variable_string_boolean_dummy function "how_many_vars" number of times 
# with the type and the number of individal observation to be generated.

def array_creation_s_b_d(how_many_vars, which_type, number_of_obs):
    x = 1
    array = []

    while x <= how_many_vars:
        new_var = create_variable_string_boolean_dummy(which_type, number_of_obs)
        array.append(new_var)
        x += 1

    return array
